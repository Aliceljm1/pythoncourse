#用*号打印五角星的形状

n=5# 每个五角星小组件的行数，一共是5个组件
#打印第1组件
#自上而下打印等边三角形，第1行1个星，第2行3个星，第3行5个星，依次类推


# 计算第1组件最后一行的星号总数，这是之前打印等边三角形总结的规律，可以查看
k1 = 2 * n - 1

# 定义第1组件的打印函数
def print_component_1(n):
    for i in range(n):
        # 打印空格, 这里让五角星对齐，需要多打印k1+2的个星星，因为第二组件第一行是(k1+2)*3个星星，可以看成三等分，想要居中就移动到第一部分结尾的位置
        print(' ' * (n - i-1 +(k1+2)), end='')
        # 打印星号
        print('*' * (2 * i + 1))


print_component_1(n)
#打印第2组件
#自上而下打印等腰梯形(上宽下窄)，假定第1组件最后一行星号总数是k1, 则本组件第1行(k1+2)*3个星，第2行(k1+2)*3 -4个星，且首尾两头各少两个星星
#总共2+2. 第三行以此类推。

# 定义新的第2组件的打印函数
def print_component_2_updated(n, k1):
    for i in range(n):
        # 打印首部空格
        print(' ' * (2 * i), end='')
        # 打印星号
        print('*' * ((k1 + 2) * 3 - 4 * i))


print_component_2_updated(n, k1)
# 计算第2组件最后一行的星星个数， 观察print_component_2_updated 函数 可以把i修改为n-1 得出最后依次循环的值，因为最后依次循环i的值就是n-1
k2 = (k1 + 2) * 3 - 4 * (n - 1)

#打印第3组件，假定第2组件最后一行星星个数是k2,则本组件第一行是k2+2个星星，
# 且每行都要先打印t个空格，t的初始值是9，每行递减1，
#每行处于中间位置的星星记为p
#第二行处于p的左右1个位置用空格代替，总共是1*2两个，且星星空格总数和上一行相比多两个(其余行也是如此)
#第三行处于p的左右3个位置用空格代替，总共是3*2六个，第三行处于p的左右5个位置用空格代替，依次类推，直到打完所有行

# 定义最新的第3组件的打印函数，根据最新的逻辑
# 定义根据最新逻辑的第3组件的打印函数
def print_component_3_final(n, k2):
    t = 9
    for i in range(n):
        # 计算左右空格的数量
        spaces_around_p = ((i - 1) * 2 + 1) * 2 if i > 0 else 0
        # 打印前置空格
        print(' ' * t, end='')
        # 打印星号和空格
        stars_before_p = '*' * ((k2 - spaces_around_p) // 2)
        stars_after_p = '*' * ((k2 - spaces_around_p) // 2 + 2 -(n-i) )
        print(stars_before_p + ' ' * spaces_around_p + stars_after_p)
        # 减少空格数量
        t -= 1

# 打印第3组件
print_component_3_final(n, k2)